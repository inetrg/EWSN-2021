/*
 * Copyright (C) 2020 HAW Hamburg
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup     examples
 * @{
 *
 * @file
 * @brief       Application to measure AES CTR and CBC runtime
 *
 * @author      Lena Boeckmann <lena.boeckmann@haw-hamburg.de>
 *
 * @}
 */

#include <stdio.h>
#include <stdint.h>
#include <string.h>

#include "crypto/aes.h"
#include "crypto/ciphers.h"

#include "periph/gpio.h"
#include "xtimer.h"

#define ENABLE_DEBUG    (0)
#include "debug.h"

/* AES Test */
#if AES_CBC || AES_CTR || AES_ECB
    static uint8_t KEY[] = {
        0x2b, 0x7e, 0x15, 0x16, 0x28, 0xae, 0xd2, 0xa6,
        0xab, 0xf7, 0x15, 0x88, 0x09, 0xcf, 0x4f, 0x3c
    };
    static uint8_t KEY_LEN = 16;

#endif

#ifdef AES_CBC

    static uint8_t CBC_IV[16] = {
        0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,
        0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f
    };
#ifndef INPUT_512
    static uint8_t __attribute__((aligned)) CBC_PLAIN[] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0xae, 0x2d, 0x8a, 0x57, 0x1e, 0x03, 0xac, 0x9c,
        0x9e, 0xb7, 0x6f, 0xac, 0x45, 0xaf, 0x8e, 0x51
    };
    static uint8_t CBC_PLAIN_LEN = 32;

    static uint8_t __attribute__((aligned)) CBC_CIPHER[] = {
        0x76, 0x49, 0xab, 0xac, 0x81, 0x19, 0xb2, 0x46,
        0xce, 0xe9, 0x8e, 0x9b, 0x12, 0xe9, 0x19, 0x7d,
        0x50, 0x86, 0xcb, 0x9b, 0x50, 0x72, 0x19, 0xee,
        0x95, 0xdb, 0x11, 0x3a, 0x91, 0x76, 0x78, 0xb2
    };
    static uint8_t CBC_CIPHER_LEN = 32;
#else
    static unsigned char CBC_PLAIN[] = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Ste";
    #define CBC_PLAIN_LEN 512

    static uint8_t __attribute__((aligned)) CBC_CIPHER[] = {
        0xfa, 0xf4, 0x41, 0xbb, 0x79, 0x4a, 0x7a, 0x3e,
        0x27, 0x4f, 0x28, 0x6d, 0x11, 0x25, 0x7b, 0xc0,
        0xb8, 0x36, 0xab, 0x12, 0x1c, 0xd3, 0x5c, 0x3f,
        0x95, 0x3a, 0x55, 0x02, 0x36, 0x00, 0x5d, 0x12,
        0x80, 0x93, 0xf5, 0x53, 0xf1, 0xa3, 0x3a, 0x7c,
        0xac, 0x2f, 0x47, 0xe6, 0x85, 0x9b, 0xcd, 0x9f,
        0xfb, 0x8e, 0x22, 0xdd, 0xb3, 0xc0, 0x4c, 0x4f,
        0x7c, 0x26, 0x2b, 0x05, 0x4b, 0x21, 0x98, 0x53,
        0x1d, 0x09, 0x42, 0x90, 0x1f, 0x51, 0x44, 0x70,
        0xa6, 0xde, 0x84, 0x45, 0x6b, 0xb6, 0x71, 0x7f,
        0xc7, 0x83, 0x7c, 0x15, 0x8f, 0x1b, 0x9e, 0x47,
        0x0a, 0x41, 0xe6, 0x6c, 0x90, 0xf9, 0x37, 0x08,
        0xa5, 0x12, 0x38, 0x34, 0x46, 0x30, 0xc8, 0x47,
        0xaa, 0x77, 0x82, 0xd7, 0xda, 0xa7, 0x31, 0xcb,
        0xdc, 0x7c, 0xae, 0x2b, 0x69, 0xa7, 0xa1, 0x7a,
        0xd2, 0x87, 0x85, 0x82, 0xcd, 0xf0, 0xb2, 0x1b,
        0x11, 0x84, 0x65, 0x0a, 0x73, 0xad, 0x63, 0xff,
        0x62, 0x64, 0xfd, 0x95, 0x83, 0x97, 0x66, 0x91,
        0xac, 0xc1, 0x4f, 0x2f, 0xfe, 0xbc, 0xd4, 0xdd,
        0xe2, 0x75, 0xbd, 0x96, 0xa9, 0xb2, 0x85, 0x8b,
        0xe2, 0xe7, 0x95, 0x98, 0x66, 0x64, 0x1f, 0x75,
        0x07, 0x39, 0x56, 0x7f, 0x31, 0xc2, 0xe6, 0x6e,
        0x9b, 0xf0, 0xf9, 0x24, 0xc0, 0xae, 0x98, 0x19,
        0x71, 0x35, 0x81, 0x85, 0xf9, 0x1f, 0x50, 0xc1,
        0x9c, 0x83, 0xac, 0x95, 0x19, 0x9f, 0x4c, 0x65,
        0x93, 0x67, 0x7d, 0x04, 0xf1, 0x73, 0x89, 0x06,
        0xeb, 0xf3, 0xf2, 0x15, 0xc7, 0xf0, 0xf1, 0xcc,
        0x96, 0xed, 0x09, 0xa2, 0xaf, 0x36, 0x5d, 0x5b,
        0x9f, 0x8b, 0xb2, 0x4e, 0x0d, 0x7d, 0x4c, 0x19,
        0xcd, 0x36, 0xaf, 0x45, 0xfd, 0x3f, 0x03, 0xca,
        0x96, 0x15, 0x79, 0xd0, 0x6a, 0x8c, 0x2b, 0xc8,
        0xb1, 0x45, 0x49, 0x8f, 0x96, 0xa0, 0x2c, 0xa2,
        0x04, 0xa2, 0x98, 0xa3, 0xa0, 0xce, 0x15, 0x00,
        0x64, 0xeb, 0x81, 0x9f, 0xdb, 0xd8, 0x28, 0x83,
        0xc4, 0x1b, 0x83, 0x77, 0x59, 0x7d, 0x5f, 0x33,
        0x23, 0x95, 0x29, 0x8b, 0x3a, 0x1f, 0xff, 0x5a,
        0x4d, 0xe3, 0x6f, 0xd4, 0x99, 0xbe, 0x7a, 0x6b,
        0x3d, 0x6c, 0x5b, 0x3e, 0x2a, 0xd0, 0x8a, 0x50,
        0x65, 0xd1, 0xba, 0xcc, 0xa9, 0x17, 0xcd, 0xbd,
        0xb7, 0xd3, 0xf2, 0x39, 0x20, 0xb2, 0x3e, 0xb3,
        0x69, 0x08, 0x80, 0xdd, 0x81, 0x01, 0xad, 0xb3,
        0xd5, 0x34, 0x2a, 0x99, 0x8c, 0x33, 0x9a, 0xf9,
        0x37, 0xd6, 0x4b, 0x39, 0x9e, 0xc0, 0x77, 0x9a,
        0x20, 0xf3, 0xd0, 0x98, 0xdc, 0x35, 0x18, 0xde,
        0x04, 0xa5, 0x70, 0x59, 0x2f, 0x5b, 0xca, 0x94,
        0x76, 0x8e, 0xb8, 0x03, 0x4b, 0x90, 0x69, 0x5f,
        0x70, 0x94, 0xe7, 0x05, 0x7b, 0x09, 0xbc, 0x3c,
        0x4b, 0x14, 0xa1, 0x87, 0x82, 0x42, 0xaa, 0x2c,
        0x24, 0xe3, 0xaf, 0x19, 0x3d, 0x50, 0xfa, 0xff,
        0xd2, 0x98, 0xef, 0xa3, 0x5b, 0x37, 0x9b, 0xda,
        0x07, 0x7b, 0x04, 0x5c, 0xb2, 0x47, 0x9d, 0x42,
        0xc1, 0xc5, 0xdf, 0x75, 0xec, 0x38, 0x74, 0x3e,
        0xaf, 0xf4, 0x30, 0x90, 0x1b, 0x1a, 0x45, 0x82,
        0x7d, 0x7e, 0xf8, 0x22, 0x4d, 0x3e, 0xac, 0x37,
        0x03, 0x10, 0x29, 0x50, 0x29, 0x68, 0x70, 0xf9,
        0xd1, 0xd6, 0x35, 0xd7, 0xdc, 0x1d, 0x52, 0x08,
        0x72, 0x51, 0x61, 0x94, 0x96, 0x56, 0xa6, 0xfd,
        0x63, 0xaa, 0x99, 0x08, 0xc1, 0xd7, 0x37, 0x73,
        0x0f, 0x9d, 0xa6, 0x7e, 0xe5, 0x9e, 0x53, 0x21,
        0xa2, 0x89, 0xd0, 0x4b, 0x33, 0xf9, 0x9f, 0x6a,
        0x02, 0x47, 0x41, 0x95, 0x83, 0x8c, 0x15, 0x5a,
        0xcb, 0x80, 0xad, 0x5b, 0x1a, 0x5f, 0xbe, 0xc9,
        0xca, 0xd2, 0xd5, 0xdf, 0x5d, 0x7f, 0x56, 0x76,
        0xfd, 0x74, 0x39, 0x94, 0x70, 0x28, 0x85, 0x1c
    };
    #define CBC_CIPHER_LEN 512


#endif /* INPUT_512 */

    void aes_cbc_test(gpio_t active_gpio)
    {
        int ret;
        cipher_context_t ctx;
        uint8_t data[CBC_PLAIN_LEN];
        memset(data, 0, CBC_PLAIN_LEN);

        xtimer_sleep(1);
        for(int i=0;i<TEST_ENERGY_ITER;i++) {
            printf("Iteration %i/%i\n", i, TEST_ENERGY_ITER);

            gpio_set(active_gpio);
            ret = aes_init(&ctx, KEY, KEY_LEN);
            gpio_clear(active_gpio);
            if (ret < 1) {
                printf("AES CBC Enc Init failed: %d\n", ret);
                return;
            }

            gpio_set(active_gpio);
            ret = aes_encrypt_cbc(&ctx, CBC_IV, CBC_PLAIN, CBC_PLAIN_LEN, data);
            gpio_clear(active_gpio);

            if (ret < 0) {
                printf("AES CBC Encrypt failed: %d\n", ret);
                return;
            }

            if (memcmp(data, CBC_CIPHER, CBC_CIPHER_LEN)) {
                printf("AES CBC encryption wrong cipher\n");
            }

            gpio_set(active_gpio);
            ret = aes_decrypt_cbc(&ctx, CBC_IV, CBC_CIPHER, CBC_CIPHER_LEN, data);
            gpio_clear(active_gpio);

            if (ret < 0) {
                printf("AES CBC Decrypt failed: %d\n", ret);
                return;
            }

            if (memcmp(data, CBC_PLAIN, CBC_CIPHER_LEN)) {
                printf("AES CBC decryption wrong plain text\n");
                return;
            }
            else {
                puts("SUCCESS");
            }
        }
        printf("AES CBC encrypt/decrypt done\n");
    }
#endif /* AES_CBC */

#ifdef AES_ECB

#ifndef INPUT_512
    // static uint8_t __attribute__((aligned)) ECB_PLAIN[] = {
    //     0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
    //     0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
    // };
    // static uint8_t ECB_PLAIN_LEN = 16;
    static uint8_t __attribute__((aligned)) ECB_PLAIN[] = {
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a,
        0x6b, 0xc1, 0xbe, 0xe2, 0x2e, 0x40, 0x9f, 0x96,
        0xe9, 0x3d, 0x7e, 0x11, 0x73, 0x93, 0x17, 0x2a
    };
    static uint8_t ECB_PLAIN_LEN = 32;

    // static uint8_t __attribute__((aligned))ECB_CIPHER[] = {
    //     0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
    //     0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
    // };
    // static uint8_t ECB_CIPHER_LEN = 16;

    static uint8_t __attribute__((aligned))ECB_CIPHER[] = {
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97,
        0x3a, 0xd7, 0x7b, 0xb4, 0x0d, 0x7a, 0x36, 0x60,
        0xa8, 0x9e, 0xca, 0xf3, 0x24, 0x66, 0xef, 0x97
    };
    static uint8_t ECB_CIPHER_LEN = 32;
#else
    static const unsigned char ECB_PLAIN[] = "Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Stet clita kasd gubergren, no sea takimata sanctus est Lorem ipsum dolor sit amet. Lorem ipsum dolor sit amet, consetetur sadipscing elitr, sed diam nonumy eirmod tempor invidunt ut labore et dolore magna aliquyam erat, sed diam voluptua. At vero eos et accusam et justo duo dolores et ea rebum. Ste";
    static size_t ECB_PLAIN_LEN = 512;

    static uint8_t __attribute__((aligned))ECB_CIPHER[] = {
        0xbf, 0xd7, 0x5c, 0xff, 0xc4, 0x2c, 0x4d, 0xf8,
        0xc7, 0xd6, 0xfa, 0x0e, 0x71, 0x5b, 0xae, 0xdb,
        0x0f, 0x0c, 0xe6, 0xb8, 0xac, 0x10, 0x27, 0x90,
        0xbf, 0xd7, 0x80, 0x78, 0xf2, 0x6e, 0x87, 0x05,
        0x25, 0x9b, 0x53, 0x92, 0xa7, 0x2c, 0x73, 0x7c,
        0x9d, 0x90, 0x51, 0x2d, 0x02, 0x39, 0xdd, 0x7d,
        0xc3, 0x8a, 0x0d, 0xc4, 0xbe, 0x88, 0x32, 0xc0,
        0xc8, 0xac, 0xa5, 0x06, 0x41, 0x09, 0x75, 0xb7,
        0xcd, 0xc9, 0xc1, 0x5d, 0xc6, 0x6c, 0xae, 0xb6,
        0xfd, 0x44, 0x76, 0x79, 0x5a, 0x9a, 0x02, 0xe0,
        0x35, 0xbf, 0x5b, 0xb4, 0xbb, 0xe9, 0x60, 0xa8,
        0x52, 0x40, 0x01, 0xf8, 0xcc, 0x03, 0x33, 0xc9,
        0x51, 0x46, 0x12, 0xe6, 0x48, 0x35, 0x26, 0xd9,
        0x49, 0x7e, 0x07, 0xa2, 0x2f, 0xb3, 0x6a, 0x22,
        0x7b, 0x9f, 0xab, 0x81, 0xc8, 0x3f, 0x73, 0xb6,
        0x4f, 0x6d, 0xd3, 0xe3, 0x77, 0xf2, 0xdd, 0xfe,
        0x65, 0xa5, 0xb2, 0xcf, 0x5a, 0x9e, 0xa8, 0xbe,
        0x37, 0x8a, 0x2e, 0x49, 0x87, 0xf6, 0x4d, 0xf8,
        0x0b, 0x05, 0x55, 0x32, 0xac, 0x75, 0xe1, 0x70,
        0x1b, 0xee, 0x8e, 0x44, 0x8c, 0xba, 0xfe, 0xff,
        0xc4, 0x72, 0xe2, 0x1d, 0x43, 0x3d, 0x09, 0x94,
        0x35, 0x68, 0x1f, 0x53, 0xb4, 0x9e, 0x1e, 0x36,
        0x08, 0xc1, 0x6c, 0xe8, 0x05, 0x6a, 0x9b, 0xc6,
        0xc1, 0x93, 0x37, 0x1d, 0x71, 0x0f, 0x39, 0x1f,
        0xb4, 0x21, 0x5c, 0x03, 0x5b, 0x7c, 0x63, 0x30,
        0xa3, 0x75, 0x06, 0xb2, 0xbf, 0x6b, 0x6a, 0x99,
        0x65, 0xfa, 0xab, 0xd3, 0x09, 0xaf, 0x6c, 0x3e,
        0x10, 0xbe, 0x2f, 0x8d, 0xff, 0x21, 0x76, 0x40,
        0x48, 0xfe, 0x0b, 0x13, 0xc8, 0xe8, 0x8d, 0x9e,
        0xea, 0x9d, 0x41, 0xa0, 0x3f, 0xc7, 0xe2, 0xa4,
        0x8f, 0xca, 0xe0, 0xbb, 0x6f, 0x9a, 0x43, 0x2d,
        0xcd, 0xc7, 0x92, 0xf3, 0x14, 0xf7, 0x61, 0xfd,
        0x10, 0x91, 0x4c, 0x13, 0xb0, 0x89, 0x9d, 0x58,
        0x50, 0x2f, 0xf0, 0x90, 0x9a, 0xce, 0x41, 0x39,
        0x77, 0x28, 0x3c, 0x25, 0x2d, 0x43, 0x65, 0x36,
        0x05, 0x5c, 0x39, 0xfe, 0xc2, 0xcf, 0x9c, 0x81,
        0x9c, 0xe0, 0xe5, 0xa0, 0xc8, 0x87, 0x80, 0x14,
        0x65, 0x4c, 0x5d, 0xa9, 0xaf, 0x7d, 0xfb, 0x60,
        0x1e, 0xc7, 0x56, 0x83, 0xfa, 0xfd, 0x95, 0x56,
        0x2f, 0xa1, 0x7b, 0x90, 0x13, 0x8e, 0x32, 0x84,
        0xe6, 0x46, 0xc6, 0x76, 0x8f, 0x7d, 0x10, 0x53,
        0x13, 0x28, 0x0b, 0x8a, 0x4b, 0x88, 0xe7, 0x19,
        0x0b, 0x1e, 0xa1, 0x37, 0x1a, 0xef, 0x01, 0x54,
        0x69, 0x90, 0x82, 0x8d, 0x43, 0x5a, 0x5e, 0xb7,
        0xda, 0x6d, 0x5e, 0x0b, 0xcf, 0x22, 0x75, 0xb7,
        0x14, 0xa5, 0xb2, 0x80, 0x7d, 0x22, 0xba, 0x2b,
        0xe2, 0x2b, 0x8e, 0x48, 0x1c, 0xdc, 0x37, 0x9c,
        0x1c, 0xb4, 0xd3, 0xf1, 0x03, 0xeb, 0x06, 0xdf,
        0x18, 0xed, 0xbc, 0x09, 0x64, 0x11, 0x45, 0x26,
        0xb6, 0xd3, 0x59, 0x01, 0xb6, 0x82, 0xcf, 0x41,
        0xcd, 0x38, 0x1d, 0xa3, 0xb9, 0xc3, 0x1c, 0x14,
        0xa0, 0x0a, 0x7f, 0x96, 0x48, 0x90, 0x1f, 0xb5,
        0xb6, 0xbb, 0x68, 0x42, 0x63, 0x9e, 0xca, 0x09,
        0xb6, 0xf1, 0x79, 0xa5, 0x69, 0xc8, 0x5e, 0x28,
        0xc0, 0xdd, 0x69, 0xe3, 0xd9, 0x40, 0x3f, 0xf6,
        0xcf, 0xc7, 0x27, 0x93, 0x32, 0x50, 0x1d, 0x87,
        0x25, 0xad, 0xb5, 0xc8, 0x16, 0xfa, 0x47, 0x60,
        0xe7, 0x00, 0x88, 0xc6, 0x01, 0xa7, 0xa2, 0xd7,
        0x1d, 0xbd, 0xfe, 0x5f, 0xbb, 0x00, 0x42, 0xd5,
        0x31, 0xba, 0xdc, 0x59, 0x3c, 0xa4, 0xcb, 0x56,
        0x1d, 0x3c, 0xbc, 0x36, 0x9e, 0x88, 0x55, 0xca,
        0xef, 0x5b, 0xce, 0xbe, 0xd8, 0x2e, 0x32, 0x6c,
        0x11, 0x3b, 0x1d, 0xc5, 0x4e, 0x20, 0x6e, 0x48,
        0x72, 0x52, 0x07, 0xc1, 0x62, 0x09, 0x37, 0x50
        };
    #define ECB_CIPHER_LEN 512
#endif /* INPUT_512 */

    void aes_ecb_test(gpio_t active_gpio)
    {
        int ret;
        cipher_context_t ctx;
        uint8_t data[ECB_PLAIN_LEN];
        memset(data, 0, ECB_PLAIN_LEN);

        xtimer_sleep(1);
        for(int i=0;i<TEST_ENERGY_ITER;i++) {
            printf("Iteration %i/%i\n", i, TEST_ENERGY_ITER);

            gpio_set(active_gpio);
            ret = aes_init(&ctx, KEY, KEY_LEN);
            gpio_clear(active_gpio);
            if (ret < 1) {
                printf("AES Init failed: %d\n", ret);
            }

            gpio_set(active_gpio);
            ret = aes_encrypt_ecb(&ctx, ECB_PLAIN, ECB_PLAIN_LEN, data);
            gpio_clear(active_gpio);
            if (ret < 0) {
                printf("AES ECB Enryption failed: %d\n", ret);
                return;
            }

            gpio_set(active_gpio);
            ret = aes_decrypt_ecb(&ctx, ECB_CIPHER, ECB_CIPHER_LEN, data);
            gpio_clear(active_gpio);

            if (ret < 0) {
                printf("AES ECB Deryption failed: %d\n", ret);
                return;
            }

            if (memcmp(data, ECB_PLAIN, ECB_PLAIN_LEN)) {
                printf("AES ECB decryption wrong plain\n");
                return;
            }
            else {
                puts("success");
            }
        }

        printf("AES ECB encrypt/decrypt done\n");
    }
#endif /* AES_ECB */